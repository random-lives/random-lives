---
layout: default
title: Timeline View
---

<style>
.timeline-view {
  padding-bottom: 40px;
}

.timeline-view h1 {
  font-size: 2.2rem;
  font-weight: 600;
  margin-bottom: 12px;
  letter-spacing: -0.02em;
}

.timeline-controls {
  margin-bottom: 16px;
}

.timeline-controls-row {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

.timeline-controls label {
  font-size: 0.9rem;
  color: #666;
  margin-right: 4px;
}

.color-btn {
  padding: 5px 12px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: #fff;
  color: #555;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.15s;
  font-family: inherit;
}

.color-btn:hover {
  border-color: #bbb;
  background: #f5f5f5;
}

.color-btn.selected {
  background: #333;
  border-color: #333;
  color: #fff;
}

.timeline-legend {
  display: flex;
  flex-wrap: wrap;
  gap: 8px 24px;
  font-size: 0.8rem;
  color: #555;
  margin-top: 12px;
  min-height: 44px;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 5px;
  white-space: nowrap;
}

.legend-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
}

.timeline-container {
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background: #fafafa;
  position: relative;
  cursor: grab;
}

.timeline-container.dragging {
  cursor: grabbing;
}

.timeline-axis {
  height: 32px;
  background: #fff;
  border-bottom: 1px solid #e0e0e0;
  position: relative;
  overflow: hidden;
}

.axis-label {
  position: absolute;
  top: 50%;
  transform: translate(-50%, -50%);
  font-size: 0.7rem;
  color: #666;
  white-space: nowrap;
}

.axis-tick {
  position: absolute;
  bottom: 0;
  width: 1px;
  height: 8px;
  background: #ccc;
  transform: translateX(-50%);
}

.timeline-canvas {
  position: relative;
  height: 400px;
  overflow: hidden;
}

.grid-line {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 1px;
  background: #eee;
  pointer-events: none;
}

.life-bar {
  position: absolute;
  cursor: pointer;
  min-width: 4px;
}

.life-bar .life-bar-visual {
  position: absolute;
  border-radius: 1px;
  transition: opacity 0.1s ease;
  min-width: 6px;
}

.life-bar:hover .life-bar-visual {
  opacity: 0.8;
}

.life-bar:hover {
  z-index: 100;
}

.timeline-tooltip {
  position: fixed;
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 8px 10px;
  font-size: 0.8rem;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  pointer-events: none;
  z-index: 1000;
  max-width: 220px;
  display: none;
}

.timeline-tooltip .tooltip-name {
  font-weight: 600;
  color: #000;
  margin-bottom: 3px;
}

.timeline-tooltip .tooltip-years {
  color: #666;
  margin-bottom: 2px;
}

.timeline-tooltip .tooltip-location {
  color: #888;
  font-size: 0.75rem;
}

.timeline-tooltip .tooltip-age {
  color: #888;
  font-size: 0.75rem;
}

.timeline-nav {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 12px;
  flex-wrap: wrap;
}

.timeline-nav-group {
  display: flex;
  align-items: center;
  gap: 4px;
}

.timeline-nav-btn {
  width: 32px;
  height: 32px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: #fff;
  color: #555;
  font-size: 1.1rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
  font-family: inherit;
  padding: 0;
  line-height: 1;
}

.timeline-nav-btn:hover {
  border-color: #bbb;
  background: #f5f5f5;
}

.timeline-nav-btn:active {
  background: #eee;
}

.preset-btn {
  padding: 5px 10px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: #fff;
  color: #555;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.15s;
  font-family: inherit;
  white-space: nowrap;
}

.preset-btn:hover {
  border-color: #bbb;
  background: #f5f5f5;
}

.preset-btn.active {
  background: #333;
  border-color: #333;
  color: #fff;
}

.nav-separator {
  width: 1px;
  height: 20px;
  background: #ddd;
  margin: 0 8px;
}

@media (max-width: 600px) {
  .timeline-canvas {
    height: 300px;
  }

  .timeline-nav {
    gap: 6px;
  }

  .preset-btn {
    font-size: 0.75rem;
    padding: 4px 8px;
  }
}
</style>

<div class="timeline-view">
  <h1>All Lives</h1>

  <div class="view-switcher">
    <a href="{{ '/lives' | relative_url }}">List</a>
    <a href="{{ '/map' | relative_url }}">Map</a>
    <a href="{{ '/timeline' | relative_url }}" class="active">Timeline</a>
  </div>

  <div class="timeline-controls">
    <div class="timeline-controls-row">
      <label>Color by:</label>
      <button type="button" class="color-btn" data-value="lifestyle">Lifestyle</button>
      <button type="button" class="color-btn" data-value="continent">Continent</button>
    </div>
    <div id="legend" class="timeline-legend"></div>
  </div>

  <div class="timeline-container" id="timeline-container" tabindex="0">
    <div class="timeline-axis" id="timeline-axis"></div>
    <div class="timeline-canvas" id="timeline-canvas"></div>
  </div>

  <div class="timeline-nav">
    <div class="timeline-nav-group">
      <button type="button" class="timeline-nav-btn" id="pan-left" title="Pan left (←)">←</button>
      <button type="button" class="timeline-nav-btn" id="pan-right" title="Pan right (→)">→</button>
    </div>
    <div class="timeline-nav-group">
      <button type="button" class="timeline-nav-btn" id="zoom-in" title="Zoom in (↑)">+</button>
      <button type="button" class="timeline-nav-btn" id="zoom-out" title="Zoom out (↓)">−</button>
    </div>
    <span class="nav-separator"></span>
    <button type="button" class="preset-btn" data-start="1526" data-end="2026">Last 500 years</button>
    <button type="button" class="preset-btn" data-start="-1000" data-end="2026">Last 3,000 years</button>
    <button type="button" class="preset-btn" data-start="-10000" data-end="2026">Last 12,000 years</button>
    <button type="button" class="preset-btn" data-start="-200000" data-end="2026">All time</button>
  </div>
</div>

<div class="timeline-tooltip" id="tooltip"></div>

<script>
(function() {
  // Parse death year from string like "1791 AD", "500 BC", "present"
  function parseDeathYear(deathYearStr, birthYear, ageAtDeath) {
    if (!deathYearStr || deathYearStr === 'present') {
      return 2026;
    }
    if (ageAtDeath !== null && ageAtDeath !== 'alive') {
      return birthYear + parseInt(ageAtDeath);
    }
    const str = deathYearStr.trim().toUpperCase();
    const bcMatch = str.match(/^(\d+)\s*(BC|BCE)$/i);
    if (bcMatch) {
      return -parseInt(bcMatch[1], 10);
    }
    const adMatch = str.match(/^(\d+)\s*(AD|CE)?$/i);
    if (adMatch) {
      return parseInt(adMatch[1], 10);
    }
    return birthYear;
  }

  // Seeded random number generator (mulberry32)
  function seededRandom(seed) {
    return function() {
      let t = seed += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  // Shuffle array with seeded RNG for deterministic order
  function shuffle(array, rng) {
    const arr = array.slice();
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(rng() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  const lives = [
    {% assign first = true %}
    {% for life in site.lives %}
    {% unless first %},{% endunless %}
    {% assign first = false %}
    {
      name: "{{ life.title | escape }}",
      url: "{{ life.url | relative_url }}",
      birthYear: {{ life.birth_year_numeric }},
      deathYearStr: "{{ life.death_year | escape }}",
      ageAtDeathRaw: "{{ life.age_at_death }}",
      years: "{% if life.birth_year == life.death_year %}{{ life.birth_year }}{% else %}{{ life.birth_year }} – {{ life.death_year }}{% endif %}",
      location: "{% if life.country %}{{ life.country | escape }}{% elsif life.region %}{{ life.region | escape }}{% endif %}",
      continent: "{{ life.continent | escape }}",
      ageTag: "{{ life.age_tag }}",
      lifestyle: "{{ life.lifestyle | escape }}"
    }
    {% endfor %}
  ];

  // Compute deathYear and ageAtDeath for each life
  lives.forEach(life => {
    life.ageAtDeath = life.ageAtDeathRaw === 'alive' ? null : parseInt(life.ageAtDeathRaw);
    life.deathYear = parseDeathYear(life.deathYearStr, life.birthYear, life.ageAtDeath);
  });

  // Shuffle for random order and assign permanent rows
  // Use fixed seed for deterministic layout across page loads
  const rng = seededRandom(42);
  const shuffledLives = shuffle(lives, rng);

  // Sort by birth year for stable row assignment
  const sortedForRows = shuffledLives.slice().sort((a, b) => a.birthYear - b.birthYear);

  // Assign permanent rows based on full timeline (not just visible portion)
  // This prevents bars from rearranging when panning/zooming
  const permanentRows = [];
  sortedForRows.forEach(life => {
    // Find first row where this bar fits (using absolute years)
    let rowIndex = 0;
    while (rowIndex < permanentRows.length) {
      // Check if there's enough gap (50 years minimum visual separation)
      if (permanentRows[rowIndex] + 50 <= life.birthYear) {
        break;
      }
      rowIndex++;
    }

    if (rowIndex >= permanentRows.length) {
      permanentRows.push(0);
    }

    life.permanentRow = rowIndex;
    permanentRows[rowIndex] = life.deathYear;
  });

  const totalPermanentRows = permanentRows.length;

  // Color schemes
  const continentColors = {
    'Africa': '#22c55e',
    'Asia': '#ef4444',
    'Europe': '#3b82f6',
    'North America': '#f59e0b',
    'South America': '#8b5cf6',
    'Oceania': '#06b6d4'
  };

  const ageColors = {
    'Alive': '#22c55e',
    'Infant (0–1)': '#ef4444',
    'Child (2–10)': '#f97316',
    'Adolescent (11–18)': '#eab308',
    'Adult (19–49)': '#3b82f6',
    'Elder (50+)': '#8b5cf6',
    'Elder (70+)': '#8b5cf6'
  };

  const ageLegendColors = {
    'Alive': '#22c55e',
    'Infant (0–1)': '#ef4444',
    'Child (2–10)': '#f97316',
    'Adolescent (11–18)': '#eab308',
    'Adult (19–49)': '#3b82f6',
    'Elder (50+)': '#8b5cf6'
  };

  const lifestyleColors = {
    'Hunter-Gatherer': '#8b5cf6',
    'Pastoralist': '#f59e0b',
    'Farmer': '#22c55e',
    'Rural Non-Farm': '#06b6d4',
    'Urban': '#ef4444'
  };

  function getColor(life, colorBy) {
    if (colorBy === 'continent') {
      return continentColors[life.continent] || '#666';
    } else if (colorBy === 'age') {
      return ageColors[life.ageTag] || '#666';
    } else if (colorBy === 'lifestyle') {
      return lifestyleColors[life.lifestyle] || '#666';
    }
    return '#555';
  }

  // Timeline bounds
  const minYear = -200000;
  const maxYear = 2026;
  const totalRange = maxYear - minYear;

  let colorBy = 'none';

  // View state - what portion of the timeline is visible
  // Start with a reasonable view (last 3000 years) instead of all 200k years
  let viewStart = -1000;
  let viewEnd = maxYear;

  const tooltip = document.getElementById('tooltip');
  const timelineContainer = document.getElementById('timeline-container');
  const timelineAxis = document.getElementById('timeline-axis');
  const timelineCanvas = document.getElementById('timeline-canvas');

  const CANVAS_HEIGHT = 400;

  function yearToPercent(year) {
    return ((year - viewStart) / (viewEnd - viewStart)) * 100;
  }

  function formatYear(year, viewRange) {
    const absYear = Math.abs(Math.round(year));
    if (year <= -10000) {
      // Show more precision when zoomed in on prehistoric times
      if (viewRange < 5000) {
        // Show full number with commas for small ranges
        return absYear.toLocaleString() + ' BC';
      } else if (viewRange < 20000) {
        // Show decimal k for medium ranges (e.g., "61.5k BC")
        const kYear = (absYear / 1000).toFixed(1);
        return kYear + 'k BC';
      } else {
        // Round to whole k for large ranges
        const kYear = Math.round(absYear / 1000);
        return kYear + 'k BC';
      }
    } else if (year < 0) {
      return absYear.toLocaleString() + ' BC';
    } else if (year < 1000) {
      return Math.round(year) + ' AD';
    }
    return Math.round(year).toString();
  }

  function getAxisTicks() {
    const viewRange = viewEnd - viewStart;
    let interval;

    // Use larger intervals for very large ranges to avoid duplicate "k BC" labels
    // Each interval should produce visually distinct labels
    if (viewRange > 150000) interval = 50000;
    else if (viewRange > 80000) interval = 25000;
    else if (viewRange > 40000) interval = 10000;
    else if (viewRange > 15000) interval = 5000;
    else if (viewRange > 8000) interval = 2000;
    else if (viewRange > 4000) interval = 1000;
    else if (viewRange > 1500) interval = 500;
    else if (viewRange > 500) interval = 100;
    else if (viewRange > 200) interval = 50;
    else if (viewRange > 50) interval = 10;
    else interval = 5;

    const ticks = [];
    const start = Math.ceil(viewStart / interval) * interval;

    for (let year = start; year <= viewEnd; year += interval) {
      ticks.push(year);
    }

    // Limit number of ticks to prevent overcrowding
    if (ticks.length > 12) {
      const step = Math.ceil(ticks.length / 10);
      return ticks.filter((_, i) => i % step === 0);
    }

    return ticks;
  }

  function renderTimeline() {
    const viewRange = viewEnd - viewStart;
    const containerWidth = timelineContainer.clientWidth;

    // Render axis
    const ticks = getAxisTicks();
    timelineAxis.innerHTML = ticks.map(year => {
      const pct = yearToPercent(year);
      if (pct < 0 || pct > 100) return '';
      return `
        <span class="axis-label" style="left: ${pct}%">${formatYear(year, viewRange)}</span>
        <span class="axis-tick" style="left: ${pct}%"></span>
      `;
    }).join('');

    // Filter visible lives
    const visibleLives = shuffledLives.filter(life =>
      life.deathYear >= viewStart && life.birthYear <= viewEnd
    );

    // Render grid lines
    const gridHtml = ticks.map(year => {
      const pct = yearToPercent(year);
      if (pct < 0 || pct > 100) return '';
      return `<div class="grid-line" style="left: ${pct}%"></div>`;
    }).join('');

    // Calculate bar height based on total permanent rows (not just visible)
    // This keeps bar sizes consistent when panning/zooming
    const barHeight = Math.max(3, Math.min(16, Math.floor(CANVAS_HEIGHT / Math.max(totalPermanentRows, 1) * 0.7)));
    const gap = Math.max(1, Math.min(3, Math.floor(barHeight / 4)));

    // Calculate positions using permanent rows
    visibleLives.forEach(life => {
      life.startPct = Math.max(0, yearToPercent(life.birthYear));
      life.endPct = Math.min(100, yearToPercent(life.deathYear));
    });

    const totalBarSpace = totalPermanentRows * (barHeight + gap);
    const verticalOffset = Math.max(0, (CANVAS_HEIGHT - totalBarSpace) / 2);
    const rowHeight = barHeight + gap;

    // For each visible life, calculate how much we can expand the click target
    // without overlapping neighboring bars (both vertically and horizontally)
    visibleLives.forEach(life => {
      // Find nearest bar above/below in same time range (vertical expansion)
      let nearestAbove = -1;
      let nearestBelow = totalPermanentRows;
      // Find nearest bar left/right in same row (horizontal expansion)
      let nearestLeftPct = 0;
      let nearestRightPct = 100;

      visibleLives.forEach(other => {
        if (other === life) return;

        // Check if time ranges overlap (for vertical neighbors)
        const overlaps = !(other.endPct < life.startPct - 1 || other.startPct > life.endPct + 1);
        if (overlaps) {
          if (other.permanentRow < life.permanentRow && other.permanentRow > nearestAbove) {
            nearestAbove = other.permanentRow;
          }
          if (other.permanentRow > life.permanentRow && other.permanentRow < nearestBelow) {
            nearestBelow = other.permanentRow;
          }
        }

        // Check if same row (for horizontal neighbors)
        if (other.permanentRow === life.permanentRow) {
          // Other bar is to the left
          if (other.endPct <= life.startPct && other.endPct > nearestLeftPct) {
            nearestLeftPct = other.endPct;
          }
          // Other bar is to the right
          if (other.startPct >= life.endPct && other.startPct < nearestRightPct) {
            nearestRightPct = other.startPct;
          }
        }
      });

      // Calculate available vertical expansion (in pixels)
      const rowsAbove = life.permanentRow - nearestAbove - 1;
      const rowsBelow = nearestBelow - life.permanentRow - 1;

      // Expand up to 6px vertically, limited by available space
      const maxExpandV = 6;
      life.expandTop = Math.min(maxExpandV, rowsAbove * rowHeight + gap);
      life.expandBottom = Math.min(maxExpandV, rowsBelow * rowHeight + gap);

      // Calculate available horizontal expansion (in percentage points)
      // Expand up to 0.5% in each direction, limited by available space
      const maxExpandH = 0.5;
      const gapLeft = life.startPct - nearestLeftPct;
      const gapRight = nearestRightPct - life.endPct;
      life.expandLeft = Math.min(maxExpandH, gapLeft / 2); // Split gap with neighbor
      life.expandRight = Math.min(maxExpandH, gapRight / 2);
    });

    // Render bars
    const barsHtml = visibleLives.map(life => {
      const color = getColor(life, colorBy);
      const top = verticalOffset + life.permanentRow * rowHeight;
      const visualWidth = life.endPct - life.startPct;
      const ageText = life.ageAtDeath !== null
        ? `Died at ${life.ageAtDeath}`
        : `Age ${maxYear - life.birthYear} (alive)`;

      // Skip if bar would be outside canvas
      if (top > CANVAS_HEIGHT) return '';

      // Clickable area expands based on available space
      const clickTop = top - life.expandTop;
      const clickHeight = barHeight + life.expandTop + life.expandBottom;
      const clickLeft = life.startPct - life.expandLeft;
      const clickWidth = visualWidth + life.expandLeft + life.expandRight;

      // Visual bar position relative to click area
      const visualLeftPx = (life.expandLeft / clickWidth) * 100;
      const visualWidthPx = (visualWidth / clickWidth) * 100;

      return `
        <a href="${life.url}" class="life-bar"
           style="left: ${clickLeft}%; width: ${Math.max(0.1, clickWidth)}%; top: ${clickTop}px; height: ${clickHeight}px;"
           data-name="${life.name}"
           data-years="${life.years}"
           data-location="${life.location}"
           data-age="${ageText}">
          <span class="life-bar-visual" style="left: ${visualLeftPx}%; width: ${visualWidthPx}%; top: ${life.expandTop}px; height: ${barHeight}px; background: ${color};"></span>
        </a>
      `;
    }).join('');

    timelineCanvas.innerHTML = gridHtml + barsHtml;

    // Add hover handlers
    document.querySelectorAll('.life-bar').forEach(bar => {
      bar.addEventListener('mouseenter', (e) => {
        tooltip.innerHTML = `
          <div class="tooltip-name">${bar.dataset.name}</div>
          <div class="tooltip-years">${bar.dataset.years}</div>
          <div class="tooltip-age">${bar.dataset.age}</div>
          <div class="tooltip-location">${bar.dataset.location}</div>
        `;
        tooltip.style.display = 'block';
      });

      bar.addEventListener('mousemove', (e) => {
        tooltip.style.left = (e.clientX + 12) + 'px';
        tooltip.style.top = (e.clientY + 12) + 'px';
      });

      bar.addEventListener('mouseleave', () => {
        tooltip.style.display = 'none';
      });
    });
  }

  function updateLegend() {
    const legend = document.getElementById('legend');
    if (colorBy === 'none') {
      legend.innerHTML = '';
      return;
    }

    let colors;
    if (colorBy === 'continent') colors = continentColors;
    else if (colorBy === 'age') colors = ageLegendColors;
    else if (colorBy === 'lifestyle') colors = lifestyleColors;

    legend.innerHTML = Object.entries(colors).map(([label, color]) => `
      <div class="legend-item">
        <span class="legend-dot" style="background: ${color}"></span>
        <span>${label}</span>
      </div>
    `).join('');
  }

  // Event listeners for color buttons
  document.querySelectorAll('.color-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const value = btn.dataset.value;
      // Toggle: if already selected, deselect (go to none)
      if (btn.classList.contains('selected')) {
        btn.classList.remove('selected');
        colorBy = 'none';
      } else {
        // Deselect all, select this one
        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        colorBy = value;
      }
      updateLegend();
      renderTimeline();
    });
  });

  // Shared zoom function
  function zoomTimeline(zoomFactor, centerPercent = 0.5) {
    const centerYear = viewStart + (viewEnd - viewStart) * centerPercent;
    const currentRange = viewEnd - viewStart;
    let newRange = currentRange * zoomFactor;

    // Clamp range
    newRange = Math.max(50, Math.min(totalRange, newRange));

    // Calculate new view centered on the specified position
    let newStart = centerYear - newRange * centerPercent;
    let newEnd = centerYear + newRange * (1 - centerPercent);

    // If zooming in near the right edge, preserve the current right-hand year
    const nearRightEdge = centerPercent > 0.8;
    const zoomingIn = zoomFactor < 1;

    if (nearRightEdge && zoomingIn) {
      newEnd = viewEnd;
      newStart = viewEnd - newRange;
    }

    // Clamp to bounds
    if (newStart < minYear) {
      viewStart = minYear;
      viewEnd = minYear + newRange;
    } else if (newEnd > maxYear) {
      viewEnd = maxYear;
      viewStart = maxYear - newRange;
    } else {
      viewStart = newStart;
      viewEnd = newEnd;
    }

    updatePresetButtons();
    renderTimeline();
  }

  // Shared pan function
  function panTimeline(deltaPercent) {
    const viewRange = viewEnd - viewStart;
    const deltaYears = deltaPercent * viewRange;

    let newStart = viewStart + deltaYears;
    let newEnd = viewEnd + deltaYears;

    // Clamp to bounds
    if (newStart < minYear) {
      newStart = minYear;
      newEnd = minYear + viewRange;
    } else if (newEnd > maxYear) {
      newEnd = maxYear;
      newStart = maxYear - viewRange;
    }

    viewStart = newStart;
    viewEnd = newEnd;
    updatePresetButtons();
    renderTimeline();
  }

  // Update preset button active states
  function updatePresetButtons() {
    document.querySelectorAll('.preset-btn').forEach(btn => {
      const presetStart = parseInt(btn.dataset.start);
      const presetEnd = parseInt(btn.dataset.end);
      const isActive = Math.abs(viewStart - presetStart) < 100 && Math.abs(viewEnd - presetEnd) < 10;
      btn.classList.toggle('active', isActive);
    });
  }

  // Mouse wheel zoom (with slower zoom for trackpads)
  timelineContainer.addEventListener('wheel', (e) => {
    e.preventDefault();

    const rect = timelineCanvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mousePercent = mouseX / rect.width;

    // Detect trackpad vs mouse wheel: trackpad typically has smaller, more frequent deltas
    // and often has non-zero deltaX for horizontal scrolling
    const isTrackpad = Math.abs(e.deltaY) < 50 || e.deltaX !== 0;

    // Use gentler zoom for trackpad (50% slower)
    const baseZoom = isTrackpad ? 1.15 : 1.3;
    const zoomFactor = e.deltaY > 0 ? baseZoom : (1 / baseZoom);

    zoomTimeline(zoomFactor, mousePercent);
  }, { passive: false });

  // Drag to pan horizontally
  let isDragging = false;
  let dragStartX = 0;
  let dragStartViewStart = 0;
  let dragStartViewEnd = 0;

  timelineContainer.addEventListener('mousedown', (e) => {
    // Don't start drag if clicking on a life bar link
    if (e.target.classList.contains('life-bar')) return;

    isDragging = true;
    dragStartX = e.clientX;
    dragStartViewStart = viewStart;
    dragStartViewEnd = viewEnd;
    timelineContainer.classList.add('dragging');
    e.preventDefault();
  });

  document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;

    const rect = timelineCanvas.getBoundingClientRect();
    const deltaX = e.clientX - dragStartX;
    const deltaPercent = deltaX / rect.width;
    const viewRange = dragStartViewEnd - dragStartViewStart;
    const deltaYears = -deltaPercent * viewRange; // Negative because drag right = move earlier in time

    let newStart = dragStartViewStart + deltaYears;
    let newEnd = dragStartViewEnd + deltaYears;

    // Clamp to bounds
    if (newStart < minYear) {
      newStart = minYear;
      newEnd = minYear + viewRange;
    } else if (newEnd > maxYear) {
      newEnd = maxYear;
      newStart = maxYear - viewRange;
    }

    viewStart = newStart;
    viewEnd = newEnd;
    renderTimeline();
  });

  document.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      timelineContainer.classList.remove('dragging');
    }
  });

  // Smooth keyboard controls with velocity and easing
  const keysPressed = new Set();
  let animationFrameId = null;
  let lastFrameTime = 0;

  // Velocity state (builds up while key held, decays when released)
  let panVelocity = 0;    // negative = left, positive = right
  let zoomVelocity = 0;   // negative = zoom in, positive = zoom out

  // Tuning parameters
  const MAX_PAN_SPEED = 0.4;      // max 40% of view per second
  const MAX_ZOOM_SPEED = 0.8;     // max 80% zoom per second (as log scale)
  const ACCELERATION = 3.0;       // how fast velocity builds up
  const FRICTION = 6.0;           // how fast velocity decays (higher = faster stop)

  function animateKeyboard(currentTime) {
    // Calculate delta time
    const deltaTime = lastFrameTime ? Math.min((currentTime - lastFrameTime) / 1000, 0.1) : 0.016;
    lastFrameTime = currentTime;

    // Calculate target velocities based on keys pressed
    let targetPan = 0;
    let targetZoom = 0;

    if (keysPressed.has('ArrowLeft')) targetPan -= MAX_PAN_SPEED;
    if (keysPressed.has('ArrowRight')) targetPan += MAX_PAN_SPEED;
    if (keysPressed.has('ArrowUp')) targetZoom -= MAX_ZOOM_SPEED;
    if (keysPressed.has('ArrowDown')) targetZoom += MAX_ZOOM_SPEED;

    // Ease velocity toward target (acceleration when key pressed)
    // Ease velocity toward zero (friction/deceleration when key released)
    if (targetPan !== 0) {
      // Accelerate toward target
      panVelocity += (targetPan - panVelocity) * ACCELERATION * deltaTime;
    } else {
      // Decelerate with friction
      panVelocity *= Math.exp(-FRICTION * deltaTime);
      if (Math.abs(panVelocity) < 0.001) panVelocity = 0;
    }

    if (targetZoom !== 0) {
      zoomVelocity += (targetZoom - zoomVelocity) * ACCELERATION * deltaTime;
    } else {
      zoomVelocity *= Math.exp(-FRICTION * deltaTime);
      if (Math.abs(zoomVelocity) < 0.001) zoomVelocity = 0;
    }

    // Stop animation if no velocity and no keys pressed
    if (panVelocity === 0 && zoomVelocity === 0 && keysPressed.size === 0) {
      animationFrameId = null;
      return;
    }

    let needsRender = false;

    // Apply pan velocity
    if (panVelocity !== 0) {
      const viewRange = viewEnd - viewStart;
      const delta = panVelocity * viewRange * deltaTime;
      let newStart = viewStart + delta;
      let newEnd = viewEnd + delta;

      if (newStart < minYear) {
        newStart = minYear;
        newEnd = minYear + viewRange;
        panVelocity = 0; // Stop at boundary
      } else if (newEnd > maxYear) {
        newEnd = maxYear;
        newStart = maxYear - viewRange;
        panVelocity = 0; // Stop at boundary
      }

      viewStart = newStart;
      viewEnd = newEnd;
      needsRender = true;
    }

    // Apply zoom velocity
    if (zoomVelocity !== 0) {
      const centerYear = (viewStart + viewEnd) / 2;
      const currentRange = viewEnd - viewStart;
      // Use exponential zoom for natural feel
      const zoomFactor = Math.exp(zoomVelocity * deltaTime);
      let newRange = currentRange * zoomFactor;

      // Clamp range
      if (newRange < 50) {
        newRange = 50;
        zoomVelocity = 0;
      } else if (newRange > totalRange) {
        newRange = totalRange;
        zoomVelocity = 0;
      }

      viewStart = centerYear - newRange / 2;
      viewEnd = centerYear + newRange / 2;

      // Clamp to bounds
      if (viewStart < minYear) {
        viewStart = minYear;
        viewEnd = minYear + newRange;
      }
      if (viewEnd > maxYear) {
        viewEnd = maxYear;
        viewStart = maxYear - newRange;
      }

      needsRender = true;
    }

    if (needsRender) {
      updatePresetButtons();
      renderTimeline();
    }

    animationFrameId = requestAnimationFrame(animateKeyboard);
  }

  document.addEventListener('keydown', (e) => {
    // Ignore if user is typing in an input field
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

    const arrowKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'];
    if (arrowKeys.includes(e.key)) {
      e.preventDefault();
      keysPressed.add(e.key);
      if (!animationFrameId) {
        lastFrameTime = 0;
        animationFrameId = requestAnimationFrame(animateKeyboard);
      }
    }
  });

  document.addEventListener('keyup', (e) => {
    keysPressed.delete(e.key);
    // Don't stop animation - let velocity decay naturally
  });

  // Stop animation if window loses focus
  window.addEventListener('blur', () => {
    keysPressed.clear();
    panVelocity = 0;
    zoomVelocity = 0;
  });

  // On-screen navigation buttons
  document.getElementById('pan-left').addEventListener('click', () => panTimeline(-0.2));
  document.getElementById('pan-right').addEventListener('click', () => panTimeline(0.2));
  document.getElementById('zoom-in').addEventListener('click', () => zoomTimeline(0.7, 0.5));
  document.getElementById('zoom-out').addEventListener('click', () => zoomTimeline(1.3, 0.5));

  // Preset view buttons
  document.querySelectorAll('.preset-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      viewStart = parseInt(btn.dataset.start);
      viewEnd = parseInt(btn.dataset.end);
      updatePresetButtons();
      renderTimeline();
    });
  });

  // Initial render
  updatePresetButtons();
  renderTimeline();

  // Handle resize
  window.addEventListener('resize', renderTimeline);
})();
</script>
